<!DOCTYPE html>
<html>
<head>
	<title>Promise</title>
	<script type="text/javascript">
		// 在JavaScript的世界中，所有代码都是单线程执行的。
		// 由于这个“缺陷”，导致JavaScript的所有网络操作，浏览器事件，都必须是异步执行。异步执行可以用回调函数实现：
		function callback() {
		    console.log('Done');
		}
		console.log('before setTimeout()');
		setTimeout(callback, 1000); // 1秒钟后调用callback函数
		console.log('after setTimeout()');


		// 观察上述代码执行，在Chrome的控制台输出可以看到：
		before setTimeout()
		after setTimeout()
		(等待1秒后)
		Done


		// 可见，异步操作会在将来的某个时间点触发一个函数调用。
		// AJAX就是典型的异步操作。以上一节的代码为例：
		request.onreadystatechange = function () {
		    if (request.readyState === 4) {
		        if (request.status === 200) {
		            return success(request.responseText);
		        } else {
		            return fail(request.status);
		        }
		    }
		}


		// 把回调函数success(request.responseText)和fail(request.status)写到一个AJAX操作里很正常，但是不好看，而且不利于代码复用。
		// 有没有更好的写法？比如写成这样：
		var ajax = ajaxGet('http://...');
		ajax.ifSuccess(success)
		    .ifFail(fail);


		 /*
		 这种链式写法的好处在于，先统一执行AJAX逻辑，不关心如何处理结果，然后，根据结果是成功还是失败，在将来的某个时候调用success函数或fail函数。
		古人云：“君子一诺千金”，这种“承诺将来会执行”的对象在JavaScript中称为Promise对象。
		Promise有各种开源实现，在ES6中被统一规范，由浏览器直接支持。先测试一下你的浏览器是否支持Promise：*/
		
		// 直接运行测试:
		new Promise(function () {});
		console.log('支持Promise!');


	</script>
</head>
<body>
	
</body>
</html>